------------------------------------------------------------------------------
--                                                                          --
--                         REFLEX COMPILER COMPONENTS                       --
--                                                                          --
--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
--                                                                          --
-- Reflex is free software; you can redistribute it  and/or modify it under --
-- terms of the  GNU General Public Licensea as published  by the Free Soft- --
-- ware Foundation; either version 3, or (at your option) any later version --
-- Reflex is distributed in the hope that it will be useful, but WITH-      --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License distributed with Reflex; see file COPYING3. If not, go to --
-- http://www.gnu.org/licenses for a complete copy of the license.          --
--                                                                          --
-- Reflex is originally developed  by the Artics team at Grenoble.          --
--                                                                          --
------------------------------------------------------------------------------

--  This package contains routines for handling the strings table which is
--  used to store string constants encountered in the source, and also those
--  additional string constants generated by compile time concatenation and
--  other similar processing.

--  A string constant in this table consists of a series of Char_Code values,
--  so that 16-bit character codes can be properly handled if this feature
--  is implemented in the scanner.

--  There is no guarantee that hashing is used in the implementation, although
--  it maybe. This means that the caller cannot count on having the same Id
--  value for two identical strings stored separately and also cannot count on
--  the two Id values being different.

with Artics.Chars_Codes; use Artics.Chars_Codes;

package Artics.Strings_Stocks is

   --  Strings_Low_Bound : constant := 400_000_000;
   --  --  Low bound for string Id values

   --  Strings_High_Bound : constant := 499_999_999;
   --  Maximum number of strings that can be allocated is 100 million, which
   --  is in practice infinite and there is no need to check the range.

   type Str_Id is new Integer;
   --  range Strings_Low_Bound .. Strings_High_Bound;
   --  Type used to identify entries in the strings table

   No_Str_Id : constant Str_Id := Str_Id'First;
   --  Used to indicate missing string Id. Note that the value zero is used
   --  to indicate a missing data value for all the Int types in this section.

   First_Str_Id : constant Str_Id := No_Str_Id + 1;
   --  First subscript allocated in string table

   Null_Str_Id : Str_Id;
   --  Gets set to a null string with length zero

   True_String  : Str_Id;
   False_String : Str_Id;

   --------------------------------------
   -- String Table Access Subprograms --
   --------------------------------------

   procedure Initialize;
   --  Initializes the strings table for a new compilation. Note that
   --  Initialize must not be called if Tree_Read is used.

   function Get_String (S : Str_Id) return String;
   --  Return the string associated with the String_Id S

   function Enter_String (S : String) return Str_Id;
   --  Stock the strign S and return the Id associated with S.

   procedure Mark;
   --  Take a snapshot of the internal tables. Used in conjunction with Release
   --  when computing temporary string values that need not be preserved.

   procedure Release;
   --  Restore the internal tables to the situation when Mark was last called.
   --  If Release is called with no prior call to Mark, the entire string table
   --  is cleared to its initial (empty) setting.

   procedure Start_String;
   --  Sets up for storing a new string in the table. To store a string, a
   --  call is first made to Start_String, then successive calls are
   --  made to Store_String_Character to store the characters of the string.
   --  Finally, a call to End_String terminates the entry and returns it Id.

   procedure Start_String (S : Str_Id);
   --  Like Start_String with no parameter, except that the contents of the
   --  new string is initialized to be a copy of the given string. A test is
   --  made to see if S is the last created string, and if so it is shared,
   --  rather than copied, this can be particularly helpful for the case of
   --  a continued concatenation of string constants.

   procedure Store_String_Char (C : Char_Code);
   procedure Store_String_Char (C : Character);
   --  Store next character of string, see description above for Start_String

   procedure Store_String_Chars (S : String);
   procedure Store_String_Chars (S : Str_Id);
   --  Store character codes of given string in sequence

   procedure Store_String_Int (N : Integer);
   --  Stored decimal representation of integer with possible leading minus

   procedure Unstore_String_Char;
   --  Undoes effect of previous Store_String_Char call, used in some error
   --  situations of unterminated string constants.

   function End_String return Str_Id;
   --  Terminates current string and returns its Id

   function String_Length (Id : Str_Id) return Natural;
   --  Returns length of previously stored string

   function Get_String_Char
     (Id    : Str_Id;
      Index : Integer) return Char_Code;
   pragma Inline (Get_String_Char);
   --  Obtains the specified character from a stored string. The lower bound
   --  of stored strings is always 1, so the range is 1 .. String_Length (Id).

   function String_Equal (L, R : Str_Id) return Boolean;
   --  Determines if two string literals represent the same string

private
   pragma Inline (End_String);
   pragma Inline (String_Length);

end Artics.Strings_Stocks;
