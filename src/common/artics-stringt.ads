------------------------------------------------------------------------------
--                                                                          --
--                         REFLEX COMPILER COMPONENTS                       --
--                                                                          --
--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
--                                                                          --
-- Reflex is free software; you can redistribute it  and/or modify it under --
-- terms of the  GNU General Public License as published  by the Free Soft- --
-- ware Foundation; either version 3, or (at your option) any later version --
-- Reflex is distributed in the hope that it will be useful, but WITH-      --
-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
-- for  more details.  You should have  received  a copy of the GNU General --
-- Public License distributed with Reflex; see file COPYING3. If not, go to --
-- http://www.gnu.org/licenses for a complete copy of the license.          --
--                                                                          --
-- Reflex is originally developed  by the Artics team at Grenoble.          --
--                                                                          --
------------------------------------------------------------------------------

with System; use System;
with Artics.Types;  use Artics.Types;

package Artics.Stringt is

--  This package contains routines for handling the strings table which is
--  used to store string constants encountered in the source, and also those
--  additional string constants generated by compile time concatenation and
--  other similar processing.

--  A string constant in this table consists of a series of Char_Code values,
--  so that 16-bit character codes can be properly handled if this feature
--  is implemented in the scanner.

--  There is no guarantee that hashing is used in the implementation, although
--  it maybe. This means that the caller cannot count on having the same Id
--  value for two identical strings stored separately and also cannot count on
--  the two Id values being different.
   
   Strings_Low_Bound : constant := 400_000_000;
   --  Low bound for string Id values

   Strings_High_Bound : constant := 499_999_999;
   --  Maximum number of strings that can be allocated is 100 million, which
   --  is in practice infinite and there is no need to check the range.

   --  The following subtype definitions are used to provide convenient names
   --  for membership tests on Int values to see what data type range they
   --  lie in. Such tests appear only in the lowest level packages.

   subtype Strings_Range   is int
     range Strings_Low_Bound .. Strings_High_Bound;
   
   type String_Id is range Strings_Low_Bound .. Strings_High_Bound;
   --  Type used to identify entries in the strings table

   No_String : constant String_Id := Strings_Low_Bound;
   --  Used to indicate missing string Id. Note that the value zero is used
   --  to indicate a missing data value for all the Int types in this section.

   First_String_Id : constant String_Id := No_String + 1;
   --  First subscript allocated in string table
   
   Max_Line_Length : constant := 4096;
   
   --------------------------------------
   -- String Table Access Subprograms --
   --------------------------------------

   procedure Initialize;
   --  Initializes the strings table for a new compilation. Note that
   --  Initialize must not be called if Tree_Read is used.

   procedure Lock;
   --  Lock internal tables before calling back end

   procedure Start_String;
   --  Sets up for storing a new string in the table. To store a string, a
   --  call is first made to Start_String, then successive calls are
   --  made to Store_String_Character to store the characters of the string.
   --  Finally, a call to End_String terminates the entry and returns it Id.

   procedure Start_String (S : String_Id);
   --  Like Start_String with no parameter, except that the contents of the
   --  new string is initialized to be a copy of the given string. A test is
   --  made to see if S is the last created string, and if so it is shared,
   --  rather than copied, this can be particularly helpful for the case of
   --  a continued concatenation of string constants.

   procedure Store_String_Char (C : Char_Code);
   procedure Store_String_Char (C : Character);
   --  Store next character of string, see description above for Start_String

   procedure Store_String_Chars (S : String);
   procedure Store_String_Chars (S : String_Id);
   --  Store character codes of given string in sequence

   procedure Store_String_Int (N : Int);
   --  Stored decimal representation of integer with possible leading minus

   procedure Unstore_String_Char;
   --  Undoes effect of previous Store_String_Char call, used in some error
   --  situations of unterminated string constants.

   function End_String return String_Id;
   --  Terminates current string and returns its Id

   function String_Length (Id : String_Id) return Natural;
   --  Returns length of previously stored string

   function Get_String_Char (Id : String_Id; Index : Integer) return Char_Code;
   pragma Inline (Get_String_Char);
   --  Obtains the specified character from a stored string. The lower bound
   --  of stored strings is always 1, so the range is 1 .. String_Length (Id).

   function String_Equal (L, R : String_Id) return Boolean;
   --  Determines if two string literals represent the same string

   procedure String_To_Name_Buffer (S : String_Id);
   --  Place characters of given string in Name_Buffer, setting Name_Len.
   --  Error if any characters are out of Character range. Does not attempt
   --  to do any encoding of any characters.

   procedure Add_String_To_Name_Buffer (S : String_Id);
   --  Append characters of given string to Name_Buffer, updating Name_Len.
   --  Error if any characters are out of Character range. Does not attempt
   --  to do any encoding of any characters.

   function String_Chars_Address return System.Address;
   --  Return address of String_Chars table (used by Back_End call to Gigi)

   function String_From_Name_Buffer return String_Id;
   --  Given a name stored in Namet.Name_Buffer (length in Namet.Name_Len),
   --  returns a string of the corresponding value. The value in Name_Buffer
   --  is unchanged, and the cases of letters are unchanged.

   function Strings_Address return System.Address;
   --  Return address of Strings table (used by Back_End call to Gigi)

private
   Str_Name_Buffer : String (1 .. 4 * Max_Line_Length);
   --  This buffer is used to set the name to be stored in the table for the
   --  Name_Find call, and to retrieve the name for the Get_Name_String call.
   --  The limit here is intended to be an infinite value that ensures that we
   --  never overflow the buffer (names this long are too absurd to worry!)

   Str_Name_Len : Natural;
   --  Length of name stored in Name_Buffer. Used as an input parameter for
   --  Name_Find, and as an output value by Get_Name_String, or Write_Name.

   
   pragma Inline (End_String);
   pragma Inline (String_Length);

end Artics.Stringt;
